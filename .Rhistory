unipredi$predi53<-(unipredi$rf+unipredi$xgbm+unipredi$svmLinear)/3
unipredi$predi54<-(unipredi$rf+unipredi$xgbm+unipredi$svmPoly)/3
unipredi$predi55<-(unipredi$rf+unipredi$xgbm+unipredi$svmRadial)/3
unipredi$predi56<-(unipredi$rf+unipredi$avnnet+unipredi$gbm)/3
unipredi$predi57<-(unipredi$rf+unipredi$avnnet+unipredi$xgbm)/3
unipredi$predi58<-(unipredi$rf+unipredi$avnnet+unipredi$svmLinear)/3
unipredi$predi59<-(unipredi$rf+unipredi$avnnet+unipredi$svmPoly)/3
unipredi$predi60<-(unipredi$rf+unipredi$avnnet+unipredi$svmRadial)/3
unipredi$predi61<-(unipredi$avnnet+unipredi$gbm+unipredi$svmLinear)/3
unipredi$predi62<-(unipredi$avnnet+unipredi$gbm+unipredi$svmPoly)/3
unipredi$predi63<-(unipredi$avnnet+unipredi$gbm+unipredi$svmRadial)/3
unipredi$predi64<-(unipredi$logi+unipredi$rf+unipredi$gbm+unipredi$avnnet)/4
unipredi$predi65<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet)/4
unipredi$predi66<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet)/4
unipredi$predi67<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet+unipredi$svmLinear)/5
unipredi$predi68<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet+unipredi$svmPoly)/5
unipredi$predi69<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet+unipredi$svmRadial)/5
# Listado de modelos a considerar, cambiar al gusto
dput(names(unipredi))
unipredi
listado<-c("logi", "avnnet",
"rf","gbm",  "xgbm", "svmLinear",  "svmPoly",
"svmRadial","predi9", "predi10", "predi11", "predi12",
"predi13", "predi14", "predi15", "predi16", "predi17", "predi18",
"predi19", "predi20", "predi21", "predi22", "predi23", "predi24",
"predi25", "predi26", "predi27", "predi28", "predi29", "predi30",
"predi31", "predi32", "predi33", "predi34", "predi35", "predi36",
"predi37", "predi38", "predi39", "predi40", "predi41", "predi42",
"predi43", "predi44", "predi45", "predi46", "predi47", "predi48",
"predi49", "predi50", "predi51", "predi52", "predi53", "predi54",
"predi55", "predi56", "predi57", "predi58", "predi59", "predi60",
"predi61", "predi62", "predi63", "predi64", "predi65", "predi66",
"predi67", "predi68", "predi69")
tasafallos<-function(x,y) {
confu<-confusionMatrix(x,y)
tasa<-confu[[3]][1]
return(tasa)
}
auc<-function(x,y) {
curvaroc<-roc(response=x,predictor=y)
auc<-curvaroc$auc
return(auc)
}
unipredi
repeticiones<-nlevels(factor(unipredi$Rep))
unipredi$Rep<-as.factor(unipredi$Rep)
unipredi$Rep<-as.numeric(unipredi$Rep)
unipredi
medias0<-data.frame(c())
for (prediccion in listado)
{
unipredi$proba<-unipredi[,prediccion]
unipredi[,prediccion]<-ifelse(unipredi[,prediccion]>0.5,"Yes","No")
for (repe in 1:repeticiones)
{
paso <- unipredi[(unipredi$Rep==repe),]
pre<-factor(paso[,prediccion])
archi<-paso[,c("proba","obs")]
archi<-archi[order(archi$proba),]
obs<-paso[,c("obs")]
tasa=1-tasafallos(pre,obs)
t<-as.data.frame(tasa)
t$modelo<-prediccion
auc<-suppressMessages(auc(archi$obs,archi$proba))
t$auc<-auc
medias0<-rbind(medias0,t)
}
}
par(cex.axis=0.5,las=2)
boxplot(data=medias0,tasa~modelo,col="pink",main="TASA FALLOS")
boxplot(data=medias0,auc~modelo,col="pink",main="AUC")
save.image("~/Desktop/ensamblado.RData")
load("/Users/alberto/Downloads/ensamblado.RData")
load("/Users/alberto/Downloads/ensamblado.RData")
par(cex.axis=0.5,las=2)
boxplot(data=medias0,tasa~modelo,col="pink",main="TASA FALLOS")
boxplot(data=medias0,auc~modelo,col="pink",main="AUC")
load("/Users/alberto/Downloads/ensamblado.RData")
par(cex.axis=0.8)
boxplot(data=union1,tasa~modelo,col="pink",main='TASA FALLOS')
boxplot(data=union1,auc~modelo,col="pink",main='AUC')
# CONSTRUCCIÓN DE TODOS LOS ENSAMBLADOS
# SE UTILIZARÁN LOS ARCHIVOS SURGIDOS DE LAS FUNCIONES LLAMADOS predi1,...
unipredi<-cbind(predi1,predi2,predi3,predi4,predi5,predi6,predi7,predi8)
# Esto es para eliminar columnas duplicadas
unipredi<- unipredi[, !duplicated(colnames(unipredi))]
unipredi$predi9<-(unipredi$logi+unipredi$avnnet)/2
unipredi$predi10<-(unipredi$logi+unipredi$rf)/2
unipredi$predi11<-(unipredi$logi+unipredi$gbm)/2
unipredi$predi12<-(unipredi$logi+unipredi$xgbm)/2
unipredi$predi13<-(unipredi$logi+unipredi$svmLinear)/2
unipredi$predi14<-(unipredi$logi+unipredi$svmPoly)/2
unipredi$predi15<-(unipredi$logi+unipredi$svmRadial)/2
unipredi$predi16<-(unipredi$avnnet+unipredi$rf)/2
unipredi$predi17<-(unipredi$avnnet+unipredi$gbm)/2
unipredi$predi18<-(unipredi$avnnet+unipredi$xgbm)/2
unipredi$predi19<-(unipredi$avnnet+unipredi$svmLinear)/2
unipredi$predi20<-(unipredi$avnnet+unipredi$svmPoly)/2
unipredi$predi21<-(unipredi$avnnet+unipredi$svmRadial)/2
unipredi$predi22<-(unipredi$rf+unipredi$gbm)/2
unipredi$predi23<-(unipredi$rf+unipredi$xgbm)/2
unipredi$predi24<-(unipredi$rf+unipredi$svmLinear)/2
unipredi$predi25<-(unipredi$rf+unipredi$svmPoly)/2
unipredi$predi26<-(unipredi$rf+unipredi$svmRadial)/2
unipredi$predi27<-(unipredi$gbm+unipredi$xgbm)/2
unipredi$predi28<-(unipredi$gbm+unipredi$svmLinear)/2
unipredi$predi29<-(unipredi$gbm+unipredi$svmPoly)/2
unipredi$predi30<-(unipredi$gbm+unipredi$svmRadial)/2
unipredi$predi31<-(unipredi$logi+unipredi$avnnet+unipredi$rf)/3
unipredi$predi32<-(unipredi$logi+unipredi$avnnet+unipredi$gbm)/3
unipredi$predi33<-(unipredi$logi+unipredi$avnnet+unipredi$xgbm)/3
unipredi$predi34<-(unipredi$logi+unipredi$avnnet+unipredi$svmLinear)/3
unipredi$predi35<-(unipredi$logi+unipredi$avnnet+unipredi$svmPoly)/3
unipredi$predi36<-(unipredi$logi+unipredi$avnnet+unipredi$svmRadial)/3
unipredi$predi37<-(unipredi$logi+unipredi$rf+unipredi$gbm)/3
unipredi$predi38<-(unipredi$logi+unipredi$rf+unipredi$xgbm)/3
unipredi$predi39<-(unipredi$logi+unipredi$rf+unipredi$svmLinear)/3
unipredi$predi40<-(unipredi$logi+unipredi$rf+unipredi$svmPoly)/3
unipredi$predi41<-(unipredi$logi+unipredi$rf+unipredi$svmRadial)/3
unipredi$predi42<-(unipredi$logi+unipredi$gbm+unipredi$xgbm)/3
unipredi$predi43<-(unipredi$logi+unipredi$gbm+unipredi$xgbm)/3
unipredi$predi44<-(unipredi$logi+unipredi$gbm+unipredi$svmLinear)/3
unipredi$predi45<-(unipredi$logi+unipredi$gbm+unipredi$svmPoly)/3
unipredi$predi46<-(unipredi$logi+unipredi$gbm+unipredi$svmRadial)/3
unipredi$predi47<-(unipredi$logi+unipredi$xgbm+unipredi$svmLinear)/3
unipredi$predi48<-(unipredi$logi+unipredi$xgbm+unipredi$svmPoly)/3
unipredi$predi49<-(unipredi$logi+unipredi$xgbm+unipredi$svmRadial)/3
unipredi$predi50<-(unipredi$rf+unipredi$gbm+unipredi$svmLinear)/3
unipredi$predi51<-(unipredi$rf+unipredi$gbm+unipredi$svmPoly)/3
unipredi$predi52<-(unipredi$rf+unipredi$gbm+unipredi$svmRadial)/3
unipredi$predi53<-(unipredi$rf+unipredi$xgbm+unipredi$svmLinear)/3
unipredi$predi54<-(unipredi$rf+unipredi$xgbm+unipredi$svmPoly)/3
unipredi$predi55<-(unipredi$rf+unipredi$xgbm+unipredi$svmRadial)/3
unipredi$predi56<-(unipredi$rf+unipredi$avnnet+unipredi$gbm)/3
unipredi$predi57<-(unipredi$rf+unipredi$avnnet+unipredi$xgbm)/3
unipredi$predi58<-(unipredi$rf+unipredi$avnnet+unipredi$svmLinear)/3
unipredi$predi59<-(unipredi$rf+unipredi$avnnet+unipredi$svmPoly)/3
unipredi$predi60<-(unipredi$rf+unipredi$avnnet+unipredi$svmRadial)/3
unipredi$predi61<-(unipredi$avnnet+unipredi$gbm+unipredi$svmLinear)/3
unipredi$predi62<-(unipredi$avnnet+unipredi$gbm+unipredi$svmPoly)/3
unipredi$predi63<-(unipredi$avnnet+unipredi$gbm+unipredi$svmRadial)/3
unipredi$predi64<-(unipredi$logi+unipredi$rf+unipredi$gbm+unipredi$avnnet)/4
unipredi$predi65<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet)/4
unipredi$predi66<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet)/4
unipredi$predi67<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet+unipredi$svmLinear)/5
unipredi$predi68<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet+unipredi$svmPoly)/5
unipredi$predi69<-(unipredi$logi+unipredi$rf+unipredi$xgbm+unipredi$avnnet+unipredi$svmRadial)/5
# Listado de modelos a considerar, cambiar al gusto
dput(names(unipredi))
listado<-c("logi", "avnnet",
"rf","gbm",  "xgbm", "svmLinear",  "svmPoly",
"svmRadial","predi9", "predi10", "predi11", "predi12",
"predi13", "predi14", "predi15", "predi16", "predi17", "predi18",
"predi19", "predi20", "predi21", "predi22", "predi23", "predi24",
"predi25", "predi26", "predi27", "predi28", "predi29", "predi30",
"predi31", "predi32", "predi33", "predi34", "predi35", "predi36",
"predi37", "predi38", "predi39", "predi40", "predi41", "predi42",
"predi43", "predi44", "predi45", "predi46", "predi47", "predi48",
"predi49", "predi50", "predi51", "predi52", "predi53", "predi54",
"predi55", "predi56", "predi57", "predi58", "predi59", "predi60",
"predi61", "predi62", "predi63", "predi64", "predi65", "predi66",
"predi67", "predi68", "predi69")
tasafallos<-function(x,y) {
confu<-confusionMatrix(x,y)
tasa<-confu[[3]][1]
return(tasa)
}
auc<-function(x,y) {
curvaroc<-roc(response=x,predictor=y)
auc<-curvaroc$auc
return(auc)
}
source("./librerias/cruzadas ensamblado binaria fuente.R")
setwd("/Users/alberto/Downloads/")
knitr::opts_chunk$set(echo = TRUE)
library(readr)
dataset <- read_csv("wine_dataset.csv")
library(dplyr)
dataset <-dataset %>%
group_by(style) %>%
sample_frac(size = .05, replace = F)
dataset$quality <- ifelse(dataset$quality <= 5, "Poor", "Cool")
dataset$style <- ifelse(dataset$style=="red", 1, 0)
library(readr)
dataset <- read_csv("wine_dataset.csv")
library(dplyr)
dataset <-dataset %>%
group_by(style) %>%
sample_frac(size = .05, replace = F)
dataset$quality <- ifelse(dataset$quality <= 5, "Poor", "Cool")
dataset$style <- ifelse(dataset$style=="red", 1, 0)
# Funcion para normalizar
normalize <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
data_norm <- as.data.frame(lapply(dataset[,-c(12, 13)], normalize))
data_norm$quality <- dataset$quality
data_norm$style <- dataset$style
library(dummies)
data_norm$quality_Cool <- dummy(data_norm$quality)[,1]
data_norm$quality_Poor <- dummy(data_norm$quality)[,2]
data_norm$quality <- NULL
# Se pasa la variable objetivo a factor.
data_norm$style <- as.factor(data_norm$style)
dput(names(data_norm))
c("fixed_acidity", "volatile_acidity", "citric_acid", "residual_sugar",
"chlorides", "free_sulfur_dioxide", "total_sulfur_dioxide", "density",
"pH", "sulphates", "alcohol", "style", "quality_Cool", "quality_Poor"
)
full<-glm(style~.,data=data_norm, family = binomial(link="logit"))
null<-glm(style~1,data=data_norm, family = binomial(link="logit"))
library(MASS)
selec1<-stepAIC(null,scope=list(upper=full),direction="both",trace=FALSE)
summary(selec1)
formula <- selec1$formula
selec2<-stepAIC(null,scope=list(upper=full),direction="forward",trace=FALSE)
summary(selec2)
selec2$formula
selec3<-stepAIC(full,scope=list(upper=null),direction="backward",trace=FALSE)
summary(selec3)
selec3$formula
dput(names(selec3))
View(dataset)
library(caret)
data_norm$style <- as.factor(data_norm$style)
levels(data_norm$style) <- c("No", "Yes")
control <- trainControl(method = "repeatedcv", number=4, repeats=5, savePredictions = "all", classProbs=TRUE)
glm <- train(style ~ total_sulfur_dioxide + density + residual_sugar + alcohol +
volatile_acidity + chlorides + free_sulfur_dioxide + sulphates +
citric_acid,
data=data_norm,trControl=control, method="glm",family = binomial(link="logit"))
glm
avnnetgrid <-expand.grid(size=c(5,10,15,20),
decay=c(0.01,0.1,0.001),bag=FALSE)
redavnnet <- train(style ~ total_sulfur_dioxide + density + residual_sugar + alcohol +
volatile_acidity + chlorides + free_sulfur_dioxide + sulphates +
citric_acid, data=data_norm, method="avNNet", trControl=control, tuneGrid=avnnetgrid, repeats=5, trace=FALSE)
plot(redavnnet)
source("cruzada rf binaria.R")
source("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada rf binaria.R")
variables <- c("total_sulfur_dioxide", "density",  "residual_sugar",  "alcohol",
"volatile_acidity", "chlorides",  "free_sulfur_dioxide", "sulphates",
"citric_acid")
medias1 <- cruzadarfbin(data=data_norm, vardep="style", listconti=variables, listclass=c(""), grupos=10,sinicio=1234,repe=20,nodesize=10, mtry=2,ntree=3000,replace=TRUE,sampsize=50)
medias1$modelo = "bagging50"
medias2 <- cruzadarfbin(data=data_norm, vardep="style", listconti=variables, listclass=c(""), grupos=10,sinicio=1234,repe=20,nodesize=10, mtry=2,ntree=3000,replace=TRUE,sampsize=100)
medias2$modelo = "bagging100"
medias3 <- cruzadarfbin(data=data_norm, vardep="style", listconti=variables, listclass=c(""), grupos=10,sinicio=1234,repe=20,nodesize=10, mtry=2,ntree=3000,replace=TRUE,sampsize=150)
medias3$modelo = "bagging150"
medias4 <- cruzadarfbin(data=data_norm, vardep="style", listconti=variables, listclass=c(""), grupos=10,sinicio=1234,repe=20,nodesize=10, mtry=2,ntree=3000,replace=TRUE,sampsize=200)
medias4$modelo = "bagging200"
bagging.union<-rbind(medias1,medias2,medias3,medias4)
par(cex.axis=0.8)
boxplot(data=bagging.union,tasa~modelo,main="TASA FALLOS",col="pink")
boxplot(data=bagging.union,auc~modelo,main="AUC",col="pink")
rfgrid<-expand.grid(mtry=c(3,4,5,6,7,8))
rf <- train(style ~ total_sulfur_dioxide + density + residual_sugar + alcohol +
volatile_acidity + chlorides + free_sulfur_dioxide + sulphates +
citric_acid, data=data_norm, method="rf", trControl=control, tuneGrid=rfgrid, linout = FALSE, ntree=300, nodesize=10, replace=TRUE, importance=TRUE)
plot(rf)
gbmgrid<-expand.grid(shrinkage=c(0.2,0.1,0.05,0.03,0.01,0.001),
n.minobsinnode=c(5,10,20),
n.trees=c(100,500,1000,5000),
interaction.depth=c(2))
gbm <- train(style ~ total_sulfur_dioxide + density + residual_sugar + alcohol +
volatile_acidity + chlorides + free_sulfur_dioxide + sulphates +
citric_acid,  data=data_norm,  method="gbm", trControl=control, tuneGrid=gbmgrid,
distribution="bernoulli", bag.fraction=1, verbose=FALSE)
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzadas avnnet y log binaria.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada arbolbin.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzadas avnnet y log binaria.R")
# source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada arbolbin.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada rf binaria.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada gbm binaria.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada SVM binaria lineal.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada SVM binaria polinomial.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada SVM binaria RBF.R")
variables <- c("total_sulfur_dioxide", "density",  "residual_sugar",  "alcohol",
"volatile_acidity", "chlorides",  "free_sulfur_dioxide", "sulphates",
"citric_acid")
# Se transforma la varible dependiente a Yes y No
data_norm$style <- ifelse(data_norm$style == 1, "Yes", "No")
medias1<-cruzadalogistica(data=data_norm,
vardep="style",
listconti= variables,
listclass=c(""),
grupos=4,
sinicio=1234,
repe=5)
variables
data_norm
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzadas avnnet y log binaria.R")
# source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada arbolbin.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada rf binaria.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada gbm binaria.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada SVM binaria lineal.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada SVM binaria polinomial.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada SVM binaria RBF.R")
variables <- c("total_sulfur_dioxide", "density",  "residual_sugar",  "alcohol",
"volatile_acidity", "chlorides",  "free_sulfur_dioxide", "sulphates",
"citric_acid")
# Se transforma la varible dependiente a Yes y No
data_norm$style <- ifelse(data_norm$style == 1, "Yes", "No")
medias1<-cruzadalogistica(data=data_norm,
vardep="style",
listconti= variables,
listclass=c(""),
grupos=4,
sinicio=1234,
repe=5)
dput(names(data_norm))
sapply(data_norm, class)
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzadas avnnet y log binaria.R")
# source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada arbolbin.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada rf binaria.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada gbm binaria.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada SVM binaria lineal.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada SVM binaria polinomial.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada SVM binaria RBF.R")
variables <- c("total_sulfur_dioxide", "density",  "residual_sugar",  "alcohol",
"volatile_acidity", "chlorides",  "free_sulfur_dioxide", "sulphates",
"citric_acid")
# Se transforma la varible dependiente a Yes y No
data_norm$style <- ifelse(data_norm$style == 1, "Yes", "No")
data_norm$style <- as.factor(data_norm$style)
medias1<-cruzadalogistica(data=data_norm,
vardep="style",
listconti= variables,
listclass=c(""),
grupos=4,
sinicio=1234,
repe=5)
sapply(data_norm, class)
unique(data_norm$style)
# Funcion para normalizar
normalize <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
data_norm <- as.data.frame(lapply(dataset[,-c(12, 13)], normalize))
data_norm$quality <- dataset$quality
data_norm$style <- dataset$style
library(dummies)
data_norm$quality_Cool <- dummy(data_norm$quality)[,1]
data_norm$quality_Poor <- dummy(data_norm$quality)[,2]
data_norm$quality <- NULL
# Se pasa la variable objetivo a factor.
data_norm$style <- as.factor(data_norm$style)
dput(names(data_norm))
c("fixed_acidity", "volatile_acidity", "citric_acid", "residual_sugar",
"chlorides", "free_sulfur_dioxide", "total_sulfur_dioxide", "density",
"pH", "sulphates", "alcohol", "style", "quality_Cool", "quality_Poor"
)
full<-glm(style~.,data=data_norm, family = binomial(link="logit"))
null<-glm(style~1,data=data_norm, family = binomial(link="logit"))
library(MASS)
selec1<-stepAIC(null,scope=list(upper=full),direction="both",trace=FALSE)
summary(selec1)
formula <- selec1$formula
selec2<-stepAIC(null,scope=list(upper=full),direction="forward",trace=FALSE)
summary(selec2)
selec2$formula
selec3<-stepAIC(full,scope=list(upper=null),direction="backward",trace=FALSE)
summary(selec3)
selec3$formula
dput(names(selec3))
unique(data_norm$style)
library(caret)
data_norm$style <- as.factor(data_norm$style)
levels(data_norm$style) <- c("No", "Yes")
control <- trainControl(method = "repeatedcv", number=4, repeats=5, savePredictions = "all", classProbs=TRUE)
data_norm$aux_style <- ifelse(data_norm$style == 1, "Yes", "No")
unique(data_norm$style)
data_norm$aux_style <- NULL
# Se transforma la varible dependiente a Yes y No
data_norm$style <- ifelse(
data_norm$style == 1,
"Yes",
"No"
)
unique(data_norm$style)
# Funcion para normalizar
normalize <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
data_norm <- as.data.frame(lapply(dataset[,-c(12, 13)], normalize))
data_norm$quality <- dataset$quality
data_norm$style <- dataset$style
library(dummies)
data_norm$quality_Cool <- dummy(data_norm$quality)[,1]
data_norm$quality_Poor <- dummy(data_norm$quality)[,2]
data_norm$quality <- NULL
library(readr)
dataset <- read_csv("wine_dataset.csv")
library(dplyr)
dataset <-dataset %>%
group_by(style) %>%
sample_frac(size = .05, replace = F)
dataset$quality <- ifelse(dataset$quality <= 5, "Poor", "Cool")
dataset$style <- ifelse(dataset$style=="red", 1, 0)
# Funcion para normalizar
normalize <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
data_norm <- as.data.frame(lapply(dataset[,-c(12, 13)], normalize))
data_norm$quality <- dataset$quality
data_norm$style <- dataset$style
library(dummies)
data_norm$quality_Cool <- dummy(data_norm$quality)[,1]
data_norm$quality_Poor <- dummy(data_norm$quality)[,2]
data_norm$quality <- NULL
# Se pasa la variable objetivo a factor.
data_norm$style <- as.factor(data_norm$style)
dput(names(data_norm))
c("fixed_acidity", "volatile_acidity", "citric_acid", "residual_sugar",
"chlorides", "free_sulfur_dioxide", "total_sulfur_dioxide", "density",
"pH", "sulphates", "alcohol", "style", "quality_Cool", "quality_Poor"
)
full<-glm(style~.,data=data_norm, family = binomial(link="logit"))
null<-glm(style~1,data=data_norm, family = binomial(link="logit"))
library(MASS)
selec1<-stepAIC(null,scope=list(upper=full),direction="both",trace=FALSE)
summary(selec1)
formula <- selec1$formula
selec2<-stepAIC(null,scope=list(upper=full),direction="forward",trace=FALSE)
summary(selec2)
selec2$formula
selec3<-stepAIC(full,scope=list(upper=null),direction="backward",trace=FALSE)
summary(selec3)
selec3$formula
dput(names(selec3))
library(caret)
data_norm$style <- as.factor(data_norm$style)
levels(data_norm$style) <- c("No", "Yes")
control <- trainControl(method = "repeatedcv", number=4, repeats=5, savePredictions = "all", classProbs=TRUE)
data_norm$style == factor(1)
data_norm$style == as.factor(1)
as.numeric(data_norm$style) == 1
table(data_norm$style)
# Se transforma la varible dependiente a Yes y No
data_norm$style <- ifelse(
as.numeric(data_norm$style) == 1,
"Yes",
"No"
)
table(data_norm$style)
knitr::opts_chunk$set(echo = TRUE)
library(readr)
dataset <- read_csv("wine_dataset.csv")
library(dplyr)
dataset <-dataset %>%
group_by(style) %>%
sample_frac(size = .05, replace = F)
dataset$quality <- ifelse(dataset$quality <= 5, "Poor", "Cool")
dataset$style <- ifelse(dataset$style=="red", 1, 0)
# Funcion para normalizar
normalize <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
data_norm <- as.data.frame(lapply(dataset[,-c(12, 13)], normalize))
data_norm$quality <- dataset$quality
data_norm$style <- dataset$style
library(dummies)
data_norm$quality_Cool <- dummy(data_norm$quality)[,1]
data_norm$quality_Poor <- dummy(data_norm$quality)[,2]
data_norm$quality <- NULL
# Se pasa la variable objetivo a factor.
data_norm$style <- as.factor(data_norm$style)
dput(names(data_norm))
c("fixed_acidity", "volatile_acidity", "citric_acid", "residual_sugar",
"chlorides", "free_sulfur_dioxide", "total_sulfur_dioxide", "density",
"pH", "sulphates", "alcohol", "style", "quality_Cool", "quality_Poor"
)
full<-glm(style~.,data=data_norm, family = binomial(link="logit"))
null<-glm(style~1,data=data_norm, family = binomial(link="logit"))
library(MASS)
selec1<-stepAIC(null,scope=list(upper=full),direction="both",trace=FALSE)
summary(selec1)
formula <- selec1$formula
selec2<-stepAIC(null,scope=list(upper=full),direction="forward",trace=FALSE)
summary(selec2)
selec2$formula
selec3<-stepAIC(full,scope=list(upper=null),direction="backward",trace=FALSE)
summary(selec3)
selec3$formula
dput(names(selec3))
table(data_norm$style)
library(caret)
data_norm$style <- as.factor(data_norm$style)
levels(data_norm$style) <- c("No", "Yes")
control <- trainControl(method = "repeatedcv", number=4, repeats=5, savePredictions = "all", classProbs=TRUE)
table(data_norm$style)
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzadas avnnet y log binaria.R")
# source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada arbolbin.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada rf binaria.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada gbm binaria.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada SVM binaria lineal.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada SVM binaria polinomial.R")
source ("../UCM/Machine Learning/Practica ML/MachineLearning/librerias/cruzada SVM binaria RBF.R")
variables <- c("total_sulfur_dioxide", "density",  "residual_sugar",  "alcohol",
"volatile_acidity", "chlorides",  "free_sulfur_dioxide", "sulphates",
"citric_acid")
medias1<-cruzadalogistica(data=data_norm,
vardep="style",
listconti= variables,
listclass=c(""),
grupos=4,
sinicio=1234,
repe=5)
medias1bis<-as.data.frame(medias1[1])
medias1bis$modelo<-"Logistica"
predi1<-as.data.frame(medias1[2])
predi1$logi<-predi1$Yes
