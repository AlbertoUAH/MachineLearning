if (any(listclass==c(""))==FALSE)
{
koko<-c(listconti,listclass)
}  else   {
koko<-c(listconti)
}
modelo<-paste(koko,sep="",collapse="+")
formu<-formula(paste(vardep,"~",modelo,sep=""))
formu
# Preparo caret
set.seed(sinicio)
control<-trainControl(method = "repeatedcv",number=grupos,repeats=repe,
savePredictions = "all",classProbs=TRUE,verboseIter = TRUE)
# Aplico caret y construyo modelo
regresion <- train(formu,data=data,
trControl=control,method="glm",family = binomial(link="logit"))
preditest<-regresion$pred
preditest$prueba<-strsplit(preditest$Resample,"[.]")
preditest$Fold <- sapply(preditest$prueba, "[", 1)
preditest$Rep <- sapply(preditest$prueba, "[", 2)
preditest$prueba<-NULL
medias.confu <- c()
tasafallos<-function(x,y) {
confu<-confusionMatrix(x,y)
tasa<-confu[[3]][1]
return(tasa)
}
# Aplicamos función sobre cada Repetición
tabla<-table(preditest$Rep)
listarep<-c(names(tabla))
medias<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
tasa=1-tasafallos(paso1$pred,paso1$obs)
medias<-rbind(medias,tasa)
}
medias.confu <- c(medias.confu, confusionMatrix(regresion))
names(medias)<-"tasa"
# CalculamoS AUC  por cada Repetición de cv
# Definimnos función
auc<-function(x,y) {
curvaroc<-roc(response=x,predictor=y)
auc<-curvaroc$auc
return(auc)
}
# Aplicamos función sobre cada Repetición
mediasbis<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
auc=auc(paso1$obs,paso1$Yes)
mediasbis<-rbind(mediasbis,auc)
}
names(mediasbis)<-"auc"
# Unimos la info de auc y de tasafallos
medias$auc<-mediasbis$auc
return(list(medias, medias.confu))
}
# *********************************
# CRUZADA avNNet
# **************
cruzadaavnnetbin<-
function(data=data,vardep="vardep",
listconti="listconti",listclass="listclass",grupos=4,sinicio=1234,repe=5,
size=c(5),decay=c(0.01),repeticiones=5,itera=100,trace=TRUE)
{
# Preparación del archivo
# b)pasar las categóricas a dummies
if (any(listclass==c(""))==FALSE)
{
databis<-data[,c(vardep,listconti,listclass)]
databis<- dummy.data.frame(databis, listclass, sep = ".")
}  else   {
databis<-data[,c(vardep,listconti)]
}
# c)estandarizar las variables continuas
# Calculo medias y dtipica de datos y estandarizo (solo las continuas)
means <-apply(databis[,listconti],2,mean)
sds<-sapply(databis[,listconti],sd)
# Estandarizo solo las continuas y uno con las categoricas
datacon<-scale(databis[,listconti], center = means, scale = sds)
numerocont<-which(colnames(databis)%in%listconti)
databis<-cbind(datacon,databis[,-numerocont,drop=FALSE ])
databis[,vardep]<-as.factor(databis[,vardep])
formu<-formula(paste(vardep,"~.",sep=""))
# Preparo caret
set.seed(sinicio)
control<-trainControl(method = "repeatedcv",number=grupos,repeats=repe,
savePredictions = "all",classProbs=TRUE, verboseIter = TRUE)
# Aplico caret y construyo modelo
avnnetgrid <-  expand.grid(size=size,decay=decay,bag=FALSE)
avnnet<- train(formu,data=databis,
method="avNNet",linout = FALSE,maxit=itera,repeats=repeticiones,
trControl=control,tuneGrid=avnnetgrid,trace=trace)
print(avnnet$results)
preditest<-avnnet$pred
preditest$prueba<-strsplit(preditest$Resample,"[.]")
preditest$Fold <- sapply(preditest$prueba, "[", 1)
preditest$Rep <- sapply(preditest$prueba, "[", 2)
preditest$prueba<-NULL
tasafallos<-function(x,y) {
confu<-confusionMatrix(x,y)
tasa<-confu[[3]][1]
return(tasa)
}
# Aplicamos función sobre cada Repetición
tabla<-table(preditest$Rep)
listarep<-c(names(tabla))
medias<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
tasa=1-tasafallos(paso1$pred,paso1$obs)
medias<-rbind(medias,tasa)
}
names(medias)<-"tasa"
# CalculamoS AUC  por cada Repetición de cv
# Definimnos función
auc<-function(x,y) {
curvaroc<-roc(response=x,predictor=y)
auc<-curvaroc$auc
return(auc)
}
# Aplicamos función sobre cada Repetición
mediasbis<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
auc=auc(paso1$obs,paso1$Yes)
mediasbis<-rbind(mediasbis,auc)
}
names(mediasbis)<-"auc"
# Unimos la info de auc y de tasafallos
medias$auc<-mediasbis$auc
return(medias)
}
## Ejemplo de utilización cruzada LOGISTICA Y AVNNET
# load ("saheartbis.Rda")
#
# medias1<-cruzadalogistica(data=saheartbis,
#  vardep="chd",listconti=c("sbp", "tobacco", "ldl",
#   "adiposity",  "obesity", "famhist.Absent"),
#  listclass=c(""), grupos=4,sinicio=1234,repe=5)
#
#  medias1$modelo="Logística"
#
#
# medias2<-cruzadaavnnetbin(data=saheartbis,
#  vardep="chd",listconti=c("sbp", "tobacco",
#   "ldl", "adiposity",  "obesity", "famhist.Absent"),
#  listclass=c(""),grupos=4,sinicio=1234,repe=5,
#   size=c(5),decay=c(0.1),repeticiones=5,itera=200)
#
#   medias2$modelo="avnnet"
#
# union1<-rbind(medias1,medias2)
#
# par(cex.axis=0.5)
# boxplot(data=union1,tasa~modelo,main="TASA FALLOS")
# boxplot(data=union1,auc~modelo,main="AUC")
#
#
#
load("/Users/alberto/UCM/Machine Learning/Practica ML/MachineLearning/redes_neuronales.RData")
load("/Users/alberto/UCM/Machine Learning/Practica ML/MachineLearning/redes_neuronales.RData")
# REDES NEURONALES
# 2 candidatos
source("./librerias/funcion steprepetido binaria.R")
source("./librerias/cruzadas avnnet y log binaria.R")
library(parallel)
library(doParallel)
library(caret)
variables.candidato.1 <- c("TotalCharges", "MonthlyCharges", "InternetService.Fiber.optic",
"OnlineSecurity.No", "tenure.cont", "TechSupport.No", "Contract.Month.to.month")
variables.candidato.2 <- c("tenure.cont", "TotalCharges", "MonthlyCharges", "InternetService.Fiber.optic",
"TechSupport.No")
vardep <- "target"
size.candidato.1 <- c(5, 10, 15, 20, 25, 30, 40)
decay.candidato.1 <- c(0.1, 0.01, 0.001)
cvnnet.candidato.1 <- cruzadaavnnetbin(data=telco.data.final,vardep=vardep,listconti=variables.candidato.1, listclass=c(""),
grupos=5,sinicio=1234,repe=10, size=size.candidato.1,decay=decay.candidato.1,repeticiones=15,itera=100)
size.candidato.1 <- c(5, 10, 15, 20, 25, 30, 40)
decay.candidato.1 <- c(0.1, 0.01, 0.001)
cvnnet.candidato.1 <- cruzadaavnnetbin(data=telco.data.final,vardep=vardep,listconti=variables.candidato.1, listclass=c(""),
grupos=5,sinicio=1234,repe=10, size=size.candidato.1,decay=decay.candidato.1,repeticiones=10,itera=100)
source("./librerias/funcion steprepetido binaria.R")
source("./librerias/cruzadas avnnet y log binaria.R")
library(parallel)
library(doParallel)
library(caret)
cluster <- makeCluster(detectCores() - 1)
registerDoParallel(cluster)
size.candidato.1 <- c(5, 10, 15, 20, 25, 30, 40)
decay.candidato.1 <- c(0.1, 0.01, 0.001)
cvnnet.candidato.1 <- cruzadaavnnetbin(data=telco.data.final,vardep=vardep,listconti=variables.candidato.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=size.candidato.1,decay=decay.candidato.1,repeticiones=5,itera=100)
# *********************************
# VALIDACIÓN CRUZADA REPETIDA Y BOXPLOT para
#
# LOGISTICA
# AVNNET
# *********************************
# saheart<-read.sas7bdat("c:/saheart.sas7bdat")
# listconti<-c("sbp", "tobacco", "ldl", "adiposity",  "obesity",
#  "alcohol", "age", "typea")
# listclass<-c("famhist")
# vardep<-c("chd")
library(plyr)
detach(package:plyr)
library(dummies)
library(MASS)
library(reshape)
library(caret)
library(dplyr)
library(pROC)
# *********************************
# CRUZADA LOGISTICA
# *********************************
cruzadalogistica <- function(data=data,vardep=NULL,
listconti=NULL,listclass=NULL,grupos=4,sinicio=1234,repe=5)
{
if (any(listclass==c(""))==FALSE)
{
for (i in 1:dim(array(listclass))) {
numindi<-which(names(data)==listclass[[i]])
data[,numindi]<-as.character(data[,numindi])
data[,numindi]<-as.factor(data[,numindi])
}
}
data[,vardep]<-as.factor(data[,vardep])
# Creo la formula para la logistica
if (any(listclass==c(""))==FALSE)
{
koko<-c(listconti,listclass)
}  else   {
koko<-c(listconti)
}
modelo<-paste(koko,sep="",collapse="+")
formu<-formula(paste(vardep,"~",modelo,sep=""))
formu
# Preparo caret
set.seed(sinicio)
control<-trainControl(method = "repeatedcv",number=grupos,repeats=repe,
savePredictions = "all",classProbs=TRUE,verboseIter = TRUE)
# Aplico caret y construyo modelo
regresion <- train(formu,data=data,
trControl=control,method="glm",family = binomial(link="logit"))
preditest<-regresion$pred
preditest$prueba<-strsplit(preditest$Resample,"[.]")
preditest$Fold <- sapply(preditest$prueba, "[", 1)
preditest$Rep <- sapply(preditest$prueba, "[", 2)
preditest$prueba<-NULL
medias.confu <- c()
tasafallos<-function(x,y) {
confu<-confusionMatrix(x,y)
tasa<-confu[[3]][1]
return(tasa)
}
# Aplicamos función sobre cada Repetición
tabla<-table(preditest$Rep)
listarep<-c(names(tabla))
medias<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
tasa=1-tasafallos(paso1$pred,paso1$obs)
medias<-rbind(medias,tasa)
}
medias.confu <- c(medias.confu, confusionMatrix(regresion))
names(medias)<-"tasa"
# CalculamoS AUC  por cada Repetición de cv
# Definimnos función
auc<-function(x,y) {
curvaroc<-roc(response=x,predictor=y)
auc<-curvaroc$auc
return(auc)
}
# Aplicamos función sobre cada Repetición
mediasbis<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
auc=auc(paso1$obs,paso1$Yes)
mediasbis<-rbind(mediasbis,auc)
}
names(mediasbis)<-"auc"
# Unimos la info de auc y de tasafallos
medias$auc<-mediasbis$auc
return(list(medias, medias.confu))
}
# *********************************
# CRUZADA avNNet
# **************
cruzadaavnnetbin<-
function(data=data,vardep="vardep",
listconti="listconti",listclass="listclass",grupos=4,sinicio=1234,repe=5,
size=c(5),decay=c(0.01),repeticiones=5,itera=100,trace=TRUE)
{
# Preparación del archivo
# b)pasar las categóricas a dummies
if (any(listclass==c(""))==FALSE)
{
databis<-data[,c(vardep,listconti,listclass)]
databis<- dummy.data.frame(databis, listclass, sep = ".")
}  else   {
databis<-data[,c(vardep,listconti)]
}
# c)estandarizar las variables continuas
# Calculo medias y dtipica de datos y estandarizo (solo las continuas)
means <-apply(databis[,listconti],2,mean)
sds<-sapply(databis[,listconti],sd)
# Estandarizo solo las continuas y uno con las categoricas
datacon<-scale(databis[,listconti], center = means, scale = sds)
numerocont<-which(colnames(databis)%in%listconti)
databis<-cbind(datacon,databis[,-numerocont,drop=FALSE ])
databis[,vardep]<-as.factor(databis[,vardep])
formu<-formula(paste(vardep,"~.",sep=""))
# Preparo caret
set.seed(sinicio)
control<-trainControl(method = "repeatedcv",number=grupos,repeats=repe,
savePredictions = "all",classProbs=TRUE, verboseIter = TRUE)
# Aplico caret y construyo modelo
avnnetgrid <-  expand.grid(size=size,decay=decay,bag=FALSE)
avnnet<- train(formu,data=databis,
method="avNNet",linout = FALSE,maxit=itera,repeats=repeticiones,
trControl=control,tuneGrid=avnnetgrid,trace=trace)
print(avnnet$results)
preditest<-avnnet$pred
preditest$prueba<-strsplit(preditest$Resample,"[.]")
preditest$Fold <- sapply(preditest$prueba, "[", 1)
preditest$Rep <- sapply(preditest$prueba, "[", 2)
preditest$prueba<-NULL
tasafallos<-function(x,y) {
confu<-confusionMatrix(x,y)
tasa<-confu[[3]][1]
return(tasa)
}
# Aplicamos función sobre cada Repetición
tabla<-table(preditest$Rep)
listarep<-c(names(tabla))
medias<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
tasa=1-tasafallos(paso1$pred,paso1$obs)
medias<-rbind(medias,tasa)
}
names(medias)<-"tasa"
# CalculamoS AUC  por cada Repetición de cv
# Definimnos función
auc<-function(x,y) {
curvaroc<-roc(response=x,predictor=y)
auc<-curvaroc$auc
return(auc)
}
# Aplicamos función sobre cada Repetición
mediasbis<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
auc=auc(paso1$obs,paso1$Yes)
mediasbis<-rbind(mediasbis,auc)
}
names(mediasbis)<-"auc"
# Unimos la info de auc y de tasafallos
medias$auc<-mediasbis$auc
return(medias)
}
## Ejemplo de utilización cruzada LOGISTICA Y AVNNET
# load ("saheartbis.Rda")
#
# medias1<-cruzadalogistica(data=saheartbis,
#  vardep="chd",listconti=c("sbp", "tobacco", "ldl",
#   "adiposity",  "obesity", "famhist.Absent"),
#  listclass=c(""), grupos=4,sinicio=1234,repe=5)
#
#  medias1$modelo="Logística"
#
#
# medias2<-cruzadaavnnetbin(data=saheartbis,
#  vardep="chd",listconti=c("sbp", "tobacco",
#   "ldl", "adiposity",  "obesity", "famhist.Absent"),
#  listclass=c(""),grupos=4,sinicio=1234,repe=5,
#   size=c(5),decay=c(0.1),repeticiones=5,itera=200)
#
#   medias2$modelo="avnnet"
#
# union1<-rbind(medias1,medias2)
#
# par(cex.axis=0.5)
# boxplot(data=union1,tasa~modelo,main="TASA FALLOS")
# boxplot(data=union1,auc~modelo,main="AUC")
#
#
#
size.candidato.1 <- c(5, 10, 15, 20, 25, 30, 40)
decay.candidato.1 <- c(0.1, 0.01, 0.001)
cvnnet.candidato.1 <- cruzadaavnnetbin(data=telco.data.final,vardep=vardep,listconti=variables.candidato.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=size.candidato.1,decay=decay.candidato.1,repeticiones=5,itera=100)
load("~/UCM/Machine Learning/Practica ML/MachineLearning/seleccion_variables.RData")
candidato.aic <- unlist(strsplit(tabla.aic[order(tabla.aic$Freq, decreasing = TRUE), ][1,1], split = "+", fixed = TRUE))
candidato.bic <- unlist(strsplit(tabla.bic[order(tabla.bic$Freq, decreasing = TRUE), ][1,1], split = "+", fixed = TRUE))
# Opcion 2. Random Feature Elimination
vector.semillas <- vector(mode="list", length=6)
for(i in seq(1,5)) {
vector.semillas[[i]] <- seq(12345, 12365)
}
vector.semillas[6] <- 12345
# Con regresion logistica
control.lr <- rfeControl(functions = lrFuncs, method = "cv", number = 5, repeats = 5, seeds = vector.semillas)
salida.rfe.lr <- rfe(telco.data.final[, c(columnas, "tenure.cont")], telco.data.final[, vardep], sizes = c(1:20), rfeControl = control.rf)
predictors(salida.rfe.rf)
plot(salida.rfe.rf, type=c("g", "o"))
# Con random forest
control.rf <- rfeControl(functions = rfFuncs, method = "cv", number = 5, repeats = 5, seeds = vector.semillas)
salida.rfe.rf <- rfe(telco.data.final[, c(columnas, "tenure.cont")], telco.data.final[, vardep], sizes = c(1:20), rfeControl = control.rf)
predictors(salida.rfe.rf)
plot(salida.rfe.rf, type=c("g", "o"))
# ************************************
# APLICANDO cruzadalogistica a los modelos candidatos
# ************************************
medias.base<-cruzadalogistica(data=telco.data.final, vardep="target",listconti=c("tenure.cont", "TotalCharges", "MonthlyCharges", "InternetService.Fiber.optic", "TechSupport.No"), listclass=c(""), grupos=5,sinicio=1234,repe=5)
medias.base.df <- data.frame(medias.base[1])
medias.base.df$modelo="RFE LR-RF TOP 5"
medias1<-cruzadalogistica(data=telco.data.final, vardep="target",listconti=c("Contract.Month.to.month", "InternetService.Fiber.optic", "TotalCharges", "InternetService.DSL",
"StreamingMovies.No", "PaperlessBilling", "Contract.One.year", "StreamingTV.No", "PaymentMethod.Electronic.check",
"OnlineSecurity.No", "tenure.0.5", "TechSupport.No", "Dependents"), listclass=c(""), grupos=5,sinicio=1234,repe=5)
medias1.df <- data.frame(medias1[1])
medias1.df$modelo="LOGISTICA AIC"
medias2<-cruzadalogistica(data=telco.data.final, vardep="target",listconti=c("Contract.Month.to.month", "InternetService.Fiber.optic", "TotalCharges", "InternetService.DSL",
"StreamingMovies.No", "PaperlessBilling", "Contract.One.year", "StreamingTV.No", "PaymentMethod.Electronic.check",
"OnlineSecurity.No"), listclass=c(""), grupos=5,sinicio=1234,repe=5)
medias2.df <- data.frame(medias2[1])
medias2.df$modelo="LOGISTICA BIC"
# Diferencia entre ambos modelos
setdiff(predictors(salida.rfe.rf), candidato.bic)
setdiff(candidato.bic, predictors(salida.rfe.rf))
medias3<-cruzadalogistica(data=telco.data.final, vardep="target",listconti=c("TotalCharges", "MonthlyCharges", "InternetService.Fiber.optic", "OnlineSecurity.No", "tenure.18", "tenure.0.5",
"TechSupport.No", "Contract.Month.to.month", "InternetService.DSL"), listclass=, c(""), grupos=5,sinicio=1234,repe=5)
medias3.df <- data.frame(medias3[1])
medias3.df$modelo="LOGISTICA RFE"
union1<-rbind(medias1.df,medias2.df,medias3.df)
par(cex.axis=0.5)
boxplot(data=union1,tasa~modelo,main="TASA FALLOS", col = "#F28773", lwd = 1)
par(cex.axis=0.5)
boxplot(data=union1,auc~modelo,main="AUC", col = "#F28773", lwd = 1)
medias4<-cruzadalogistica(data=telco.data.final, vardep="target",listconti=c("Contract.Month.to.month", "InternetService.Fiber.optic", "TotalCharges", "InternetService.DSL",
"StreamingMovies.No", "PaperlessBilling", "Contract.One.year", "StreamingTV.No", "PaymentMethod.Electronic.check",
"OnlineSecurity.No", "tenure.cont", "TechSupport.No", "Dependents"), listclass=c(""), grupos=5,sinicio=1234,repe=5)
medias4.df <- data.frame(medias4[1])
medias4.df$modelo="LOGISTICA AIC CON tenure.cont"
medias5<-cruzadalogistica(data=telco.data.final, vardep="target",listconti=c("TotalCharges", "MonthlyCharges", "InternetService.Fiber.optic", "OnlineSecurity.No", "tenure.cont",
"TechSupport.No", "Contract.Month.to.month"), listclass=, c(""), grupos=5,sinicio=1234,repe=5)
medias5.df <- data.frame(medias5[1])
medias5.df$modelo="LOGISTICA RFE CON tenure.cont"
union1<-rbind(medias.base.df, medias1.df,medias2.df,medias3.df, medias4.df, medias5.df)
par(cex.axis=0.5)
boxplot(data=union1,tasa~modelo,main="TASA FALLOS", col = "#F28773", lwd = 1)
par(cex.axis=0.5)
boxplot(data=union1,auc~modelo,main="AUC", col = "#F28773", lwd = 1)
# Opcion 3. Grafico VCramer
# Calcula el V de Cramer
par(mai=c(3,1,1,1))
Vcramer<-function(v,target){
greybox::cramer(telco.data.final[, v], telco.data.final[, target])$value
}
# Gr?fico con el V de cramer de todas las variables input para saber su importancia
graficoVcramer<-function(varsInd, varDep){
vector.cramer <- c(sapply(varsInd, function(x) {Vcramer(x, varDep)}))
barplot(sort(vector.cramer,decreasing =T),las=3,ylim=c(0,1), names.arg = varsInd, cex.names=0.8)
}
graficoVcramer(c("PaperlessBilling", "Contract.One.year", "StreamingTV.No", "PaymentMethod.Electronic.check",
"StreamingMovies.No", "OnlineSecurity.No", "TechSupport.No"), vardep)
# ?Y si eliminamos OnlineSecurity.No?
medias6<-cruzadalogistica(data=telco.data.final, vardep="target",listconti=c("Contract.Month.to.month", "InternetService.Fiber.optic", "TotalCharges", "InternetService.DSL",
"StreamingMovies.No", "PaperlessBilling", "Contract.One.year", "StreamingTV.No", "PaymentMethod.Electronic.check"),
listclass=c(""), grupos=5,sinicio=1234,repe=5)
medias6.df <- data.frame(medias6[1])
medias6.df$modelo="LOGISTICA BIC SIN OnlineSecurity.No"
union1<-rbind(medias.base.df, medias1.df,medias2.df,medias3.df, medias4.df, medias5.df, medias6.df)
par(cex.axis=0.5)
boxplot(data=union1,tasa~modelo,main="TASA FALLOS", col = "#F28773", lwd = 1)
par(cex.axis=0.5)
boxplot(data=union1,auc~modelo,main="AUC", col = "#F28773", lwd = 1)
for(modelo in c(medias.base, medias1,medias2,medias3, medias4, medias5, medias6)) {
print(modelo$table)
}
# Al finalizar
stopCluster(cluster)
registerDoSEQ()
salida.rfe.lr
salida.rfe.rf
save.image("~/UCM/Machine Learning/Practica ML/MachineLearning/seleccion_variables.RData")
rm(list=setdiff(ls(), "telco.data.final"))
source("./librerias/funcion steprepetido binaria.R")
source("./librerias/cruzadas avnnet y log binaria.R")
library(parallel)
library(doParallel)
library(caret)
cluster <- makeCluster(detectCores() - 1)
registerDoParallel(cluster)
variables.candidato.1 <- c("TotalCharges", "MonthlyCharges", "InternetService.Fiber.optic",
"OnlineSecurity.No", "tenure.cont", "TechSupport.No", "Contract.Month.to.month")
variables.candidato.2 <- c("tenure.cont", "TotalCharges", "MonthlyCharges", "InternetService.Fiber.optic",
"TechSupport.No")
vardep <- "target"
size.candidato.1 <- c(5, 10, 15, 20, 25, 30, 40)
decay.candidato.1 <- c(0.1, 0.01, 0.001)
cvnnet.candidato.1 <- cruzadaavnnetbin(data=telco.data.final,vardep=vardep,listconti=variables.candidato.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=size.candidato.1,decay=decay.candidato.1,repeticiones=5,itera=100)
# Si quisieramos 20 observaciones por parametro
# h * (k + 1) + h + 1 = 7043 / 20 ~ 352.2
# Si k = 7, entonces 9 * h + 1 = 352.2, es decir, 40 nodos
# Si k = 5, entonces 7 * h + 1 = 352.2, es decir, 50 nodos
size.candidato.2 <- c(5, 10, 15, 20, 25, 30, 40, 50)
decay.candidato.2 <- c(0.1, 0.01, 0.001)
cvnnet.candidato.2 <- cruzadaavnnetbin(data=telco.data.final,vardep=vardep,listconti=variables.candidato.2, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=size.candidato.2,decay=decay.candidato.2,repeticiones=5,itera=100)
save.image("~/UCM/Machine Learning/Practica ML/MachineLearning/redes_neuronales.RData")
