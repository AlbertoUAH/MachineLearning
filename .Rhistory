source("./librerias/bucle nodos 1.R")
as.formula(paste0(vardep, "~", conjunto.1))
as.formula(paste0(vardep, "~", paste0(conjunto.1, collapse = "+")))
source("./librerias/bucle nodos 1.R")
library(ggplot2)
repito<-function(nodos, listconti, vardep)
{
cstrength<-medic.data.final[,vardep]
# Aquí se cambia la semilla de la partición
set.seed(12347)
sample <- sample.int(n = nrow(medic.data.final),
size = floor(0.75*nrow(medic.data.final)), replace = F)
train <- medic.data.final[sample, ]
test  <- medic.data.final[-sample, ]
# Estandarizo train y test
# Los datos de test se estandarizan con las medias y d.típica de train
means <-apply(train[,listconti],2,mean,na.rm=TRUE)
sds<-sapply(train[,listconti],sd,na.rm=TRUE)
train2<-scale(train[,listconti], center = means, scale = sds)
numerocont<-which(colnames(train)%in%listconti)
train2<-cbind(train2,train[,-numerocont,drop=FALSE ])
test2<-scale(test[,listconti], center = means, scale = sds)
numerocont<-which(colnames(test)%in%listconti)
test2<-cbind(test2,test[,-numerocont,drop=FALSE ])
library(nnet)
set.seed(22342)
# Se construye la red con los datos train
red1<-nnet(data=train2,
as.formula(paste0(vardep, "~", paste0(listconti, collapse = "+"))),linout = TRUE,size=nodos,maxit=100,trace=FALSE)
summary(red1)
# Se calculan las predicciones sobre datos test
predi<-predict(red1,newdata=test2,type="raw")
# Se calcula el error de predicción sobre datos test
MSEtestred <- sum((test2$target - predi)^2)/nrow(test2)
MSEtestred
# Error cometido por el modelo de regresión
reg1<-lm(data=train2,cstrength~age+water)
summary(reg1)
# Para obtener el MSE y el RMSE
predi<-predict(reg1,newdata=test2,type="response")
# Se calcula el error de predicción sobre datos test
MSEtestreg <- sum((test2$target - predi)^2)/nrow(test2)
MSEtestreg
return(list(nodos,MSEtestred,MSEtestreg))
}
# Aquí creo un data.frame para ir guardando los datos para un gráfico
resul<-data.frame(c())
resulfin<-data.frame(c())
for (nodos in 3:35)
{
repe<-repito(nodos)
cat(repe[[1]],"\n")
print(repe[[2]])
print(repe[[3]])
nodos<-repe[[1]]
resul<-as.data.frame(nodos)
resul$red<-repe[[2]]
resul$reg<-repe[[3]]
resulfin<-rbind(resulfin,resul)
library(reshape2)
meltdf <- melt(resulfin,id="nodos")
ggplot(meltdf,aes(x=nodos,
y=value,colour=variable,group=variable)) + geom_line()+
scale_x_continuous(breaks =seq(3,35, by=1))+
theme(axis.text.x=element_text(size=7))
}
library(ggplot2)
repito<-function(nodos, conjunto.1, vardep)
{
cstrength<-medic.data.final[,vardep]
# Aquí se cambia la semilla de la partición
set.seed(12347)
sample <- sample.int(n = nrow(medic.data.final),
size = floor(0.75*nrow(medic.data.final)), replace = F)
train <- medic.data.final[sample, ]
test  <- medic.data.final[-sample, ]
# Estandarizo train y test
# Los datos de test se estandarizan con las medias y d.típica de train
means <-apply(train[,conjunto.1],2,mean,na.rm=TRUE)
sds<-sapply(train[,conjunto.1],sd,na.rm=TRUE)
train2<-scale(train[,conjunto.1], center = means, scale = sds)
numerocont<-which(colnames(train)%in%conjunto.1)
train2<-cbind(train2,train[,-numerocont,drop=FALSE ])
test2<-scale(test[,conjunto.1], center = means, scale = sds)
numerocont<-which(colnames(test)%in%conjunto.1)
test2<-cbind(test2,test[,-numerocont,drop=FALSE ])
library(nnet)
set.seed(22342)
# Se construye la red con los datos train
red1<-nnet(data=train2,
as.formula(paste0(vardep, "~", paste0(conjunto.1, collapse = "+"))),linout = TRUE,size=nodos,maxit=100,trace=FALSE)
summary(red1)
# Se calculan las predicciones sobre datos test
predi<-predict(red1,newdata=test2,type="raw")
# Se calcula el error de predicción sobre datos test
MSEtestred <- sum((test2$target - predi)^2)/nrow(test2)
MSEtestred
# Error cometido por el modelo de regresión
reg1<-lm(data=train2,cstrength~age+water)
summary(reg1)
# Para obtener el MSE y el RMSE
predi<-predict(reg1,newdata=test2,type="response")
# Se calcula el error de predicción sobre datos test
MSEtestreg <- sum((test2$target - predi)^2)/nrow(test2)
MSEtestreg
return(list(nodos,MSEtestred,MSEtestreg))
}
# Aquí creo un data.frame para ir guardando los datos para un gráfico
resul<-data.frame(c())
resulfin<-data.frame(c())
for (nodos in 3:35)
{
repe<-repito(nodos, conjunto.1, vardep)
cat(repe[[1]],"\n")
print(repe[[2]])
print(repe[[3]])
nodos<-repe[[1]]
resul<-as.data.frame(nodos)
resul$red<-repe[[2]]
resul$reg<-repe[[3]]
resulfin<-rbind(resulfin,resul)
}
library(reshape2)
meltdf <- melt(resulfin,id="nodos")
ggplot(meltdf,aes(x=nodos,
y=value,colour=variable,group=variable)) + geom_line()+
scale_x_continuous(breaks =seq(3,35, by=1))+
theme(axis.text.x=element_text(size=7))
library(ggplot2)
repito<-function(nodos, conjunto.1, vardep)
{
cstrength<-medic.data.final[,vardep]
# Aquí se cambia la semilla de la partición
set.seed(12347)
sample <- sample.int(n = nrow(medic.data.final),
size = floor(0.75*nrow(medic.data.final)), replace = F)
train <- medic.data.final[sample, ]
test  <- medic.data.final[-sample, ]
# Estandarizo train y test
# Los datos de test se estandarizan con las medias y d.típica de train
means <-apply(train[,conjunto.1],2,mean,na.rm=TRUE)
sds<-sapply(train[,conjunto.1],sd,na.rm=TRUE)
train2<-scale(train[,conjunto.1], center = means, scale = sds)
numerocont<-which(colnames(train)%in%conjunto.1)
train2<-cbind(train2,train[,-numerocont,drop=FALSE ])
test2<-scale(test[,conjunto.1], center = means, scale = sds)
numerocont<-which(colnames(test)%in%conjunto.1)
test2<-cbind(test2,test[,-numerocont,drop=FALSE ])
library(nnet)
set.seed(22342)
# Se construye la red con los datos train
red1<-nnet(data=train2,
as.formula(paste0(vardep, "~", paste0(conjunto.1, collapse = "+"))),linout = FALSE,size=nodos,maxit=100,trace=FALSE)
summary(red1)
# Se calculan las predicciones sobre datos test
predi<-predict(red1,newdata=test2,type="raw")
# Se calcula el error de predicción sobre datos test
MSEtestred <- sum((test2$target - predi)^2)/nrow(test2)
MSEtestred
# Error cometido por el modelo de regresión
reg1<-lm(data=train2,cstrength~age+water)
summary(reg1)
# Para obtener el MSE y el RMSE
predi<-predict(reg1,newdata=test2,type="response")
# Se calcula el error de predicción sobre datos test
MSEtestreg <- sum((test2$target - predi)^2)/nrow(test2)
MSEtestreg
return(list(nodos,MSEtestred,MSEtestreg))
}
# Aquí creo un data.frame para ir guardando los datos para un gráfico
resul<-data.frame(c())
resulfin<-data.frame(c())
for (nodos in 3:35)
{
repe<-repito(nodos, conjunto.1, vardep)
cat(repe[[1]],"\n")
print(repe[[2]])
print(repe[[3]])
nodos<-repe[[1]]
resul<-as.data.frame(nodos)
resul$red<-repe[[2]]
resul$reg<-repe[[3]]
resulfin<-rbind(resulfin,resul)
}
library(reshape2)
meltdf <- melt(resulfin,id="nodos")
ggplot(meltdf,aes(x=nodos,
y=value,colour=variable,group=variable)) + geom_line()+
scale_x_continuous(breaks =seq(3,35, by=1))+
theme(axis.text.x=element_text(size=7))
library(ggplot2)
repito<-function(nodos, conjunto.1, vardep)
{
cstrength<-medic.data.final[,vardep]
# Aquí se cambia la semilla de la partición
set.seed(12347)
sample <- sample.int(n = nrow(medic.data.final),
size = floor(0.75*nrow(medic.data.final)), replace = F)
train <- medic.data.final[sample, ]
test  <- medic.data.final[-sample, ]
# Estandarizo train y test
# Los datos de test se estandarizan con las medias y d.típica de train
means <-apply(train[,conjunto.1],2,mean,na.rm=TRUE)
sds<-sapply(train[,conjunto.1],sd,na.rm=TRUE)
train2<-scale(train[,conjunto.1], center = means, scale = sds)
numerocont<-which(colnames(train)%in%conjunto.1)
train2<-cbind(train2,train[,-numerocont,drop=FALSE ])
test2<-scale(test[,conjunto.1], center = means, scale = sds)
numerocont<-which(colnames(test)%in%conjunto.1)
test2<-cbind(test2,test[,-numerocont,drop=FALSE ])
library(nnet)
set.seed(22342)
# Se construye la red con los datos train
red1<-nnet(data=train2,
as.formula(paste0(vardep, "~", paste0(conjunto.1, collapse = "+"))),linout = FALSE,size=nodos,maxit=100,trace=FALSE)
summary(red1)
# Se calculan las predicciones sobre datos test
predi<-predict(red1,newdata=test2,type="raw")
# Se calcula el error de predicción sobre datos test
MSEtestred <- sum((test2$target - predi)^2)/nrow(test2)
MSEtestred
# Error cometido por el modelo de regresión
reg1<-lm(data=train2,as.formula(paste0(vardep, "~", paste0(conjunto.1, collapse = "+"))))
summary(reg1)
# Para obtener el MSE y el RMSE
predi<-predict(reg1,newdata=test2,type="response")
# Se calcula el error de predicción sobre datos test
MSEtestreg <- sum((test2$target - predi)^2)/nrow(test2)
MSEtestreg
return(list(nodos,MSEtestred,MSEtestreg))
}
# Aquí creo un data.frame para ir guardando los datos para un gráfico
resul<-data.frame(c())
resulfin<-data.frame(c())
for (nodos in 3:35)
{
repe<-repito(nodos, conjunto.1, vardep)
cat(repe[[1]],"\n")
print(repe[[2]])
print(repe[[3]])
nodos<-repe[[1]]
resul<-as.data.frame(nodos)
resul$red<-repe[[2]]
resul$reg<-repe[[3]]
resulfin<-rbind(resulfin,resul)
}
library(reshape2)
meltdf <- melt(resulfin,id="nodos")
ggplot(meltdf,aes(x=nodos,
y=value,colour=variable,group=variable)) + geom_line()+
scale_x_continuous(breaks =seq(3,35, by=1))+
theme(axis.text.x=element_text(size=7))
library(ggplot2)
repito<-function(nodos, conjunto.1, vardep)
{
cstrength<-medic.data.final[,vardep]
# Aquí se cambia la semilla de la partición
set.seed(12347)
sample <- sample.int(n = nrow(medic.data.final),
size = floor(0.75*nrow(medic.data.final)), replace = F)
train <- medic.data.final[sample, ]
test  <- medic.data.final[-sample, ]
# Estandarizo train y test
# Los datos de test se estandarizan con las medias y d.típica de train
means <-apply(train[,conjunto.1],2,mean,na.rm=TRUE)
sds<-sapply(train[,conjunto.1],sd,na.rm=TRUE)
train2<-scale(train[,conjunto.1], center = means, scale = sds)
numerocont<-which(colnames(train)%in%conjunto.1)
train2<-cbind(train2,train[,-numerocont,drop=FALSE ])
test2<-scale(test[,conjunto.1], center = means, scale = sds)
numerocont<-which(colnames(test)%in%conjunto.1)
test2<-cbind(test2,test[,-numerocont,drop=FALSE ])
library(nnet)
set.seed(22342)
# Se construye la red con los datos train
red1<-nnet(data=train2,
as.formula(paste0(vardep, "~", paste0(conjunto.1, collapse = "+"))),linout = FALSE,size=nodos,maxit=100)
summary(red1)
# Se calculan las predicciones sobre datos test
predi<-predict(red1,newdata=test2,type="prob")
# Se calcula el error de predicción sobre datos test
MSEtestred <- sum((test2$target - predi)^2)/nrow(test2)
MSEtestred
# Error cometido por el modelo de regresión
reg1<-glm(data=train2,as.formula(paste0(vardep, "~", paste0(conjunto.1, collapse = "+"))), family = binomial())
summary(reg1)
# Para obtener el MSE y el RMSE
predi<-predict(reg1,newdata=test2,type="prob")
# Se calcula el error de predicción sobre datos test
MSEtestreg <- sum((test2$target - predi)^2)/nrow(test2)
MSEtestreg
return(list(nodos,MSEtestred,MSEtestreg))
}
# Aquí creo un data.frame para ir guardando los datos para un gráfico
resul<-data.frame(c())
resulfin<-data.frame(c())
for (nodos in 3:35)
{
repe<-repito(nodos, conjunto.1, vardep)
cat(repe[[1]],"\n")
print(repe[[2]])
print(repe[[3]])
nodos<-repe[[1]]
resul<-as.data.frame(nodos)
resul$red<-repe[[2]]
resul$reg<-repe[[3]]
resulfin<-rbind(resulfin,resul)
}
library(reshape2)
meltdf <- melt(resulfin,id="nodos")
ggplot(meltdf,aes(x=nodos,
y=value,colour=variable,group=variable)) + geom_line()+
scale_x_continuous(breaks =seq(3,35, by=1))+
theme(axis.text.x=element_text(size=7))
library(ggplot2)
repito<-function(nodos, conjunto.1, vardep)
{
cstrength<-medic.data.final[,vardep]
# Aquí se cambia la semilla de la partición
set.seed(12347)
sample <- sample.int(n = nrow(medic.data.final),
size = floor(0.75*nrow(medic.data.final)), replace = F)
train <- medic.data.final[sample, ]
test  <- medic.data.final[-sample, ]
# Estandarizo train y test
# Los datos de test se estandarizan con las medias y d.típica de train
means <-apply(train[,conjunto.1],2,mean,na.rm=TRUE)
sds<-sapply(train[,conjunto.1],sd,na.rm=TRUE)
train2<-scale(train[,conjunto.1], center = means, scale = sds)
numerocont<-which(colnames(train)%in%conjunto.1)
train2<-cbind(train2,train[,-numerocont,drop=FALSE ])
test2<-scale(test[,conjunto.1], center = means, scale = sds)
numerocont<-which(colnames(test)%in%conjunto.1)
test2<-cbind(test2,test[,-numerocont,drop=FALSE ])
library(nnet)
set.seed(22342)
# Se construye la red con los datos train
red1<-nnet(data=train2,
as.formula(paste0(vardep, "~", paste0(conjunto.1, collapse = "+"))),linout = FALSE,size=nodos,maxit=100)
summary(red1)
# Se calculan las predicciones sobre datos test
predi<-predict(red1,newdata=test2,type="class")
# Se calcula el error de predicción sobre datos test
MSEtestred <- sum((test2$target - predi)^2)/nrow(test2)
MSEtestred
# Error cometido por el modelo de regresión
reg1<-glm(data=train2,as.formula(paste0(vardep, "~", paste0(conjunto.1, collapse = "+"))), family = binomial())
summary(reg1)
# Para obtener el MSE y el RMSE
predi<-predict(reg1,newdata=test2,type="prob")
# Se calcula el error de predicción sobre datos test
MSEtestreg <- sum((test2$target - predi)^2)/nrow(test2)
MSEtestreg
return(list(nodos,MSEtestred,MSEtestreg))
}
# Aquí creo un data.frame para ir guardando los datos para un gráfico
resul<-data.frame(c())
resulfin<-data.frame(c())
for (nodos in 3:35)
{
repe<-repito(nodos, conjunto.1, vardep)
cat(repe[[1]],"\n")
print(repe[[2]])
print(repe[[3]])
nodos<-repe[[1]]
resul<-as.data.frame(nodos)
resul$red<-repe[[2]]
resul$reg<-repe[[3]]
resulfin<-rbind(resulfin,resul)
}
library(reshape2)
meltdf <- melt(resulfin,id="nodos")
ggplot(meltdf,aes(x=nodos,
y=value,colour=variable,group=variable)) + geom_line()+
scale_x_continuous(breaks =seq(3,35, by=1))+
theme(axis.text.x=element_text(size=7))
rm(nodos)
rm(meltdf)
rm(resul)
rm(resulfin)
conjunto.1
cvnnet.candidato.1.1 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=30,decay=0.1,repeticiones=5,itera=200)
medias1.1.df <- data.frame(cvnnet.candidato.1.1[1])
medias1.1.df$modelo="NODOS: 30 - DECAY: 0.1"
cvnnet.candidato.1.2 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=variables.candidato.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=35,decay=0.1,repeticiones=5,itera=200)
medias1.2.df <- data.frame(cvnnet.candidato.1.2[1])
medias1.2.df$modelo="NODOS: 35 - DECAY: 0.1"
cvnnet.candidato.1.2 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=35,decay=0.1,repeticiones=5,itera=200)
medias1.2.df <- data.frame(cvnnet.candidato.1.2[1])
medias1.2.df$modelo="NODOS: 35 - DECAY: 0.1"
View(logistico.1)
x <- 2; y <- 1''
x <- 2; y <- 10
rm(x,y)
rm(repito)
# 3
cvnnet.candidato.1.3 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=40,decay=0.1,repeticiones=5,itera=200)
medias1.3.df <- data.frame(cvnnet.candidato.1.3[1])
medias1.3.df$modelo="NODOS: 40 - DECAY: 0.1"
# 4
cvnnet.candidato.1.4 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=45,decay=0.1,repeticiones=5,itera=200)
medias1.4.df <- data.frame(cvnnet.candidato.1.4[1])
medias1.4.df$modelo="NODOS: 45 - DECAY: 0.1"
# 5
cvnnet.candidato.1.5 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=25,decay=0.1,repeticiones=5,itera=200)
medias1.5.df <- data.frame(cvnnet.candidato.1.5[1])
medias1.5.df$modelo="NODOS: 25 - DECAY: 0.1"
# 6
cvnnet.candidato.1.6 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=20,decay=0.1,repeticiones=5,itera=200)
medias1.6.df <- data.frame(cvnnet.candidato.1.6[1])
medias1.6.df$modelo="NODOS: 20 - DECAY: 0.1"
# 7
cvnnet.candidato.1.7 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=15,decay=0.1,repeticiones=5,itera=200)
medias1.7.df <- data.frame(cvnnet.candidato.1.7[1])
medias1.7.df$modelo="NODOS: 15 - DECAY: 0.1"
# 8
cvnnet.candidato.1.8 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=10,decay=0.1,repeticiones=5,itera=200)
medias1.8.df <- data.frame(cvnnet.candidato.1.8[1])
medias1.8.df$modelo="NODOS: 10 - DECAY: 0.1"
# 9
cvnnet.candidato.1.9 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=5,decay=0.001,repeticiones=5,itera=200)
medias1.9.df <- data.frame(cvnnet.candidato.1.9[1])
medias1.9.df$modelo="NODOS: 5 - DECAY: 0.001"
union1<-rbind(logistico.1,medias1.1.df,medias1.2.df,medias1.3.df,medias1.4.df,medias1.5.df,medias1.6.df,medias1.7.df,medias1.8.df,medias1.9.df)
save.image("redes_neuronales.RData")
par(cex.axis=0.5)
boxplot(data=union1,tasa~modelo,main="TASA FALLOS", col = "#F28773", lwd = 1)
par(cex.axis=0.5)
boxplot(data=union1,auc~modelo,main="AUC", col = "#F28773", lwd = 1)
rm(medias1.1.df,medias1.2.df,medias1.3.df,medias1.4.df,medias1.5.df,medias1.6.df,medias1.7.df,medias1.8.df,medias1.9.df)
rm(cvnnet.candidato.1.1, cvnnet.candidato.1.2, cvnnet.candidato.1.3, cvnnet.candidato.1.4, cvnnet.candidato.1.5, cvnnet.candidato.1.6, cvnnet.candidato.1.7,
cvnnet.candidato.1.8, cvnnet.candidato.1.9)
cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=c(20,25),decay=(0.1, 0.2, 0.5),repeticiones=5,itera=200)
cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.1, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=c(20,25),decay=c(0.1, 0.2, 0.5),repeticiones=5,itera=200)
union1
# 1
cvnnet.candidato.1.1.bis <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.2, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=50,decay=0.01,repeticiones=5,itera=200)
medias1.1.df.bis <- data.frame(cvnnet.candidato.1.1.bis[1])
medias1.1.df.bis$modelo="NODOS: 50 - DECAY: 0.01"
# 2
cvnnet.candidato.1.2.bis.2 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.2, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=55,decay=0.01,repeticiones=5,itera=200)
medias1.2.df.bis <- data.frame(cvnnet.candidato.1.2.bis.2[1])
medias1.2.df.bis$modelo="NODOS: 55 - DECAY: 0.01"
# 1
cvnnet.candidato.1.1 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.2, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=30,decay=0.01,repeticiones=5,itera=200)
medias1.1.df <- data.frame(cvnnet.candidato.1.1[1])
medias1.1.df$modelo="NODOS: 30 - DECAY: 0.01"
# 2
cvnnet.candidato.1.2 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.2, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=35,decay=0.01,repeticiones=5,itera=200)
medias1.2.df <- data.frame(cvnnet.candidato.1.2[1])
medias1.2.df$modelo="NODOS: 35 - DECAY: 0.01"
# 3
cvnnet.candidato.1.3 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.2, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=40,decay=0.01,repeticiones=5,itera=200)
medias1.3.df <- data.frame(cvnnet.candidato.1.3[1])
medias1.3.df$modelo="NODOS: 40 - DECAY: 0.01"
# 4
cvnnet.candidato.1.4 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.2, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=45,decay=0.01,repeticiones=5,itera=200)
medias1.4.df <- data.frame(cvnnet.candidato.1.4[1])
medias1.4.df$modelo="NODOS: 45 - DECAY: 0.01"
# 5
cvnnet.candidato.1.5 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.2, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=25,decay=0.001,repeticiones=5,itera=200)
medias1.5.df <- data.frame(cvnnet.candidato.1.5[1])
medias1.5.df$modelo="NODOS: 25 - DECAY: 0.001"
# 6
cvnnet.candidato.1.6 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.2, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=20,decay=0.001,repeticiones=5,itera=200)
medias1.6.df <- data.frame(cvnnet.candidato.1.6[1])
medias1.6.df$modelo="NODOS: 20 - DECAY: 0.001"
# 7
cvnnet.candidato.1.7 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.2, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=15,decay=0.01,repeticiones=5,itera=200)
medias1.7.df <- data.frame(cvnnet.candidato.1.7[1])
medias1.7.df$modelo="NODOS: 15 - DECAY: 0.01"
# 8
cvnnet.candidato.1.8 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.2, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=10,decay=0.01,repeticiones=5,itera=200)
medias1.8.df <- data.frame(cvnnet.candidato.1.8[1])
medias1.8.df$modelo="NODOS: 10 - DECAY: 0.01"
# 9
cvnnet.candidato.1.9 <- cruzadaavnnetbin(data=medic.data.final,vardep=vardep,listconti=conjunto.2, listclass=c(""),
grupos=5,sinicio=1234,repe=5, size=5,decay=0.01,repeticiones=5,itera=200)
medias1.9.df <- data.frame(cvnnet.candidato.1.9[1])
medias1.9.df$modelo="NODOS: 5 - DECAY: 0.01"
union2<-rbind(logistico.1,medias1.1.df.bis,medias1.2.df.bis,medias1.1.df,medias1.2.df,medias1.3.df,medias1.4.df,medias1.5.df,medias1.6.df,medias1.7.df,medias1.8.df,medias1.9.df)
save.image("redes_neuronales.RData")
par(cex.axis=0.5)
boxplot(data=union2,tasa~modelo,main="TASA FALLOS", col = "#F28773", lwd = 1)
par(cex.axis=0.5)
boxplot(data=union2,auc~modelo,main="AUC", col = "#F28773", lwd = 1)
rm(medias1.1.df.bis,medias1.2.df.bis,medias1.1.df,medias1.2.df,medias1.3.df,medias1.4.df,medias1.5.df,medias1.6.df,medias1.7.df,medias1.8.df,medias1.9.df)
rm(cvnnet.candidato.1.1, cvnnet.candidato.1.2, cvnnet.candidato.1.3, cvnnet.candidato.1.4, cvnnet.candidato.1.5, cvnnet.candidato.1.6, cvnnet.candidato.1.7,
cvnnet.candidato.1.8, cvnnet.candidato.1.9, cvnnet.candidato.1.1.bis, cvnnet.candidato.1.2.bis.2)
save.image("~/UCM/Machine Learning/Practica ML/MachineLearning/redes_neuronales.RData")
