{
# Preparación del archivo
# b)pasar las categóricas a dummies
if (any(listclass==c(""))==FALSE)
{
databis<-data[,c(vardep,listconti,listclass)]
databis<- dummy.data.frame(databis, listclass, sep = ".")
}  else   {
databis<-data[,c(vardep,listconti)]
}
# c)estandarizar las variables continuas
# Calculo medias y dtipica de datos y estandarizo (solo las continuas)
means <-apply(databis[,listconti],2,mean)
sds<-sapply(databis[,listconti],sd)
# Estandarizo solo las continuas y uno con las categoricas
datacon<-scale(databis[,listconti], center = means, scale = sds)
numerocont<-which(colnames(databis)%in%listconti)
databis<-cbind(datacon,databis[,-numerocont,drop=FALSE ])
databis[,vardep]<-as.factor(databis[,vardep])
formu<-formula(paste("factor(",vardep,")~.",sep=""))
# Preparo caret
set.seed(sinicio)
control<-trainControl(method = "repeatedcv",number=grupos,repeats=repe,
savePredictions = "all",classProbs=TRUE)
# Aplico caret y construyo modelo
rfgrid <-expand.grid(mtry=mtry)
if  (sampsize==1)
{
rf<- train(formu,data=databis,
method="rf",trControl=control,
tuneGrid=rfgrid,nodesize=nodesize,replace=replace,ntree=ntree)
}
else  if  (sampsize!=1)
{
rf<- train(formu,data=databis,
method="rf",trControl=control,
tuneGrid=rfgrid,nodesize=nodesize,replace=replace,sampsize=sampsize,
ntree=ntree)
}
print(rf$results)
preditest<-rf$pred
preditest$prueba<-strsplit(preditest$Resample,"[.]")
preditest$Fold <- sapply(preditest$prueba, "[", 1)
preditest$Rep <- sapply(preditest$prueba, "[", 2)
preditest$prueba<-NULL
tasafallos<-function(x,y) {
confu<-confusionMatrix(x,y)
tasa<-confu[[3]][1]
return(tasa)
}
# Aplicamos función sobre cada Repetición
tabla<-table(preditest$Rep)
listarep<-c(names(tabla))
medias<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
tasa=1-tasafallos(paso1$pred,paso1$obs)
medias<-rbind(medias,tasa)
}
names(medias)<-"tasa"
# CalculamoS AUC  por cada Repetición de cv
# Definimnos función
auc<-function(x,y) {
curvaroc<-roc(response=x,predictor=y)
auc<-curvaroc$auc
return(auc)
}
# Aplicamos función sobre cada Repetición
mediasbis<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
auc=suppressMessages(auc(paso1$obs,paso1$Yes))
mediasbis<-rbind(mediasbis,auc)
}
names(mediasbis)<-"auc"
# Unimos la info de auc y de tasafallos
medias$auc<-mediasbis$auc
return(list(medias,preditest))
}
# ***************************************************************
# gbm : parámetros
#
#     Number of Boosting Iterations (n.trees, numeric)
#     Max Tree Depth (max.depth, numeric)
#     Shrinkage (shrinkage, numeric)
#     Min. Terminal Node Size (n.minobsinnode, numeric)
#
# ***************************************************************
cruzadagbmbin<-
function(data=data,vardep="vardep",
listconti="listconti",listclass="listclass",
grupos=4,sinicio=1234,repe=5,bag.fraction=1,
n.minobsinnode=20,shrinkage=0.1,n.trees=100,interaction.depth=2)
{
# Preparación del archivo
# b)pasar las categóricas a dummies
if (any(listclass==c(""))==FALSE)
{
databis<-data[,c(vardep,listconti,listclass)]
databis<- dummy.data.frame(databis, listclass, sep = ".")
}  else   {
databis<-data[,c(vardep,listconti)]
}
# c)estandarizar las variables continuas
# Calculo medias y dtipica de datos y estandarizo (solo las continuas)
means <-apply(databis[,listconti],2,mean)
sds<-sapply(databis[,listconti],sd)
# Estandarizo solo las continuas y uno con las categoricas
datacon<-scale(databis[,listconti], center = means, scale = sds)
numerocont<-which(colnames(databis)%in%listconti)
databis<-cbind(datacon,databis[,-numerocont,drop=FALSE ])
databis[,vardep]<-as.factor(databis[,vardep])
formu<-formula(paste("factor(",vardep,")~.",sep=""))
# Preparo caret
set.seed(sinicio)
control<-trainControl(method = "repeatedcv",number=grupos,repeats=repe,
savePredictions = "all",classProbs=TRUE)
# Aplico caret y construyo modelo
gbmgrid <-expand.grid(n.minobsinnode=n.minobsinnode,
shrinkage=shrinkage,n.trees=n.trees,
interaction.depth=interaction.depth)
gbm<- train(formu,data=databis,
method="gbm",trControl=control,bag.fraction=bag.fraction,
tuneGrid=gbmgrid,distribution="bernoulli",verbose=FALSE)
print(gbm$results)
preditest<-gbm$pred
preditest$prueba<-strsplit(preditest$Resample,"[.]")
preditest$Fold <- sapply(preditest$prueba, "[", 1)
preditest$Rep <- sapply(preditest$prueba, "[", 2)
preditest$prueba<-NULL
tasafallos<-function(x,y) {
confu<-confusionMatrix(x,y)
tasa<-confu[[3]][1]
return(tasa)
}
# Aplicamos función sobre cada Repetición
tabla<-table(preditest$Rep)
listarep<-c(names(tabla))
medias<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
tasa=1-tasafallos(paso1$pred,paso1$obs)
medias<-rbind(medias,tasa)
}
names(medias)<-"tasa"
# CalculamoS AUC  por cada Repetición de cv
# Definimnos función
auc<-function(x,y) {
curvaroc<-roc(response=x,predictor=y)
auc<-curvaroc$auc
return(auc)
}
# Aplicamos función sobre cada Repetición
mediasbis<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
auc=suppressMessages(auc(paso1$obs,paso1$Yes))
mediasbis<-rbind(mediasbis,auc)
}
names(mediasbis)<-"auc"
# Unimos la info de auc y de tasafallos
medias$auc<-mediasbis$auc
return(list(medias,preditest))
}
# ***************************************************************
# xgboost: parámetros
# nrounds (# Boosting Iterations)
# max_depth (Max Tree Depth)
# eta (Shrinkage)
# gamma (Minimum Loss Reduction)
# colsample_bytree (Subsample Ratio of Columns)
# min_child_weight (Minimum Sum of Instance Weight)
# subsample (Subsample Percentage)
#
# PONER linout = FALSE
# ***************************************************************
cruzadaxgbmbin<-
function(data=data,vardep="vardep",
listconti="listconti",listclass="listclass",
grupos=4,sinicio=1234,repe=5,
min_child_weight=20,eta=0.1,nrounds=100,max_depth=2,
gamma=0,colsample_bytree=1,subsample=1,alpha=0,lambda=0,lambda_bias=0)
{
# Preparación del archivo
# b)pasar las categóricas a dummies
if (any(listclass==c(""))==FALSE)
{
databis<-data[,c(vardep,listconti,listclass)]
databis<- dummy.data.frame(databis, listclass, sep = ".")
}  else   {
databis<-data[,c(vardep,listconti)]
}
# c)estandarizar las variables continuas
# Calculo medias y dtipica de datos y estandarizo (solo las continuas)
means <-apply(databis[,listconti],2,mean)
sds<-sapply(databis[,listconti],sd)
# Estandarizo solo las continuas y uno con las categoricas
datacon<-scale(databis[,listconti], center = means, scale = sds)
numerocont<-which(colnames(databis)%in%listconti)
databis<-cbind(datacon,databis[,-numerocont,drop=FALSE ])
databis[,vardep]<-as.factor(databis[,vardep])
formu<-formula(paste("factor(",vardep,")~.",sep=""))
# Preparo caret
set.seed(sinicio)
control<-trainControl(method = "repeatedcv",number=grupos,repeats=repe,
savePredictions = "all",classProbs=TRUE)
# Aplico caret y construyo modelo
xgbmgrid <-expand.grid( min_child_weight=min_child_weight,
eta=eta,nrounds=nrounds,max_depth=max_depth,
gamma=gamma,colsample_bytree=colsample_bytree,subsample=subsample)
xgbm<- train(formu,data=databis,
method="xgbTree",trControl=control,
tuneGrid=xgbmgrid,verbose=FALSE,
alpha=alpha,lambda=lambda,lambda_bias=lambda_bias)
print(xgbm$results)
preditest<-xgbm$pred
preditest$prueba<-strsplit(preditest$Resample,"[.]")
preditest$Fold <- sapply(preditest$prueba, "[", 1)
preditest$Rep <- sapply(preditest$prueba, "[", 2)
preditest$prueba<-NULL
tasafallos<-function(x,y) {
confu<-confusionMatrix(x,y)
tasa<-confu[[3]][1]
return(tasa)
}
# Aplicamos función sobre cada Repetición
tabla<-table(preditest$Rep)
listarep<-c(names(tabla))
medias<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
tasa=1-tasafallos(paso1$pred,paso1$obs)
medias<-rbind(medias,tasa)
}
names(medias)<-"tasa"
# CalculamoS AUC  por cada Repetición de cv
# Definimnos función
auc<-function(x,y) {
curvaroc<-roc(response=x,predictor=y)
auc<-curvaroc$auc
return(auc)
}
# Aplicamos función sobre cada Repetición
mediasbis<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
auc=suppressMessages(auc(paso1$obs,paso1$Yes))
mediasbis<-rbind(mediasbis,auc)
}
names(mediasbis)<-"auc"
# Unimos la info de auc y de tasafallos
medias$auc<-mediasbis$auc
return(list(medias,preditest))
}
# ***************************************************************
# svmLinear: parámetros
# Cost (C, numeric)
# PONER linout = FALSE
# ***************************************************************
cruzadaSVMbin<-
function(data=data,vardep="vardep",
listconti="listconti",listclass="listclass",
grupos=4,sinicio=1234,repe=5,
C=1,replace=TRUE)
{
# Preparación del archivo
# b)pasar las categóricas a dummies
if (any(listclass==c(""))==FALSE)
{
databis<-data[,c(vardep,listconti,listclass)]
databis<- dummy.data.frame(databis, listclass, sep = ".")
}  else   {
databis<-data[,c(vardep,listconti)]
}
# c)estandarizar las variables continuas
# Calculo medias y dtipica de datos y estandarizo (solo las continuas)
means <-apply(databis[,listconti],2,mean)
sds<-sapply(databis[,listconti],sd)
# Estandarizo solo las continuas y uno con las categoricas
datacon<-scale(databis[,listconti], center = means, scale = sds)
numerocont<-which(colnames(databis)%in%listconti)
databis<-cbind(datacon,databis[,-numerocont,drop=FALSE ])
databis[,vardep]<-as.factor(databis[,vardep])
formu<-formula(paste("factor(",vardep,")~.",sep=""))
# Preparo caret
set.seed(sinicio)
control<-trainControl(method = "repeatedcv",number=grupos,repeats=repe,
savePredictions = "all",classProbs=TRUE)
# Aplico caret y construyo modelo
SVMgrid <-expand.grid(C=C)
SVM<- train(formu,data=databis,
method="svmLinear",trControl=control,
tuneGrid=SVMgrid,replace=replace)
print(SVM$results)
preditest<-SVM$pred
preditest$prueba<-strsplit(preditest$Resample,"[.]")
preditest$Fold <- sapply(preditest$prueba, "[", 1)
preditest$Rep <- sapply(preditest$prueba, "[", 2)
preditest$prueba<-NULL
tasafallos<-function(x,y) {
confu<-confusionMatrix(x,y)
tasa<-confu[[3]][1]
return(tasa)
}
# Aplicamos función sobre cada Repetición
tabla<-table(preditest$Rep)
listarep<-c(names(tabla))
medias<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
tasa=1-tasafallos(paso1$pred,paso1$obs)
medias<-rbind(medias,tasa)
}
names(medias)<-"tasa"
# CalculamoS AUC  por cada Repetición de cv
# Definimnos función
auc<-function(x,y) {
curvaroc<-roc(response=x,predictor=y)
auc<-curvaroc$auc
return(auc)
}
# Aplicamos función sobre cada Repetición
mediasbis<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
auc=suppressMessages(auc(paso1$obs,paso1$Yes))
mediasbis<-rbind(mediasbis,auc)
}
names(mediasbis)<-"auc"
# Unimos la info de auc y de tasafallos
medias$auc<-mediasbis$auc
return(list(medias,preditest))
}
cruzadaSVMbinPoly<-
function(data=data,vardep="vardep",
listconti="listconti",listclass="listclass",
grupos=4,sinicio=1234,repe=5,
C=1,degree=2,scale=1)
{
# Preparación del archivo
# b)pasar las categóricas a dummies
if (any(listclass==c(""))==FALSE)
{
databis<-data[,c(vardep,listconti,listclass)]
databis<- dummy.data.frame(databis, listclass, sep = ".")
}  else   {
databis<-data[,c(vardep,listconti)]
}
# c)estandarizar las variables continuas
# Calculo medias y dtipica de datos y estandarizo (solo las continuas)
means <-apply(databis[,listconti],2,mean)
sds<-sapply(databis[,listconti],sd)
# Estandarizo solo las continuas y uno con las categoricas
datacon<-scale(databis[,listconti], center = means, scale = sds)
numerocont<-which(colnames(databis)%in%listconti)
databis<-cbind(datacon,databis[,-numerocont,drop=FALSE ])
databis[,vardep]<-as.factor(databis[,vardep])
formu<-formula(paste("factor(",vardep,")~.",sep=""))
# Preparo caret
set.seed(sinicio)
control<-trainControl(method = "repeatedcv",number=grupos,repeats=repe,
savePredictions = "all",classProbs=TRUE)
# Aplico caret y construyo modelo
SVMgrid <-expand.grid(C=C,degree=degree,scale=scale)
SVM<- train(formu,data=databis,
method="svmPoly",trControl=control,
tuneGrid=SVMgrid,replace=replace)
print(SVM$results)
preditest<-SVM$pred
preditest$prueba<-strsplit(preditest$Resample,"[.]")
preditest$Fold <- sapply(preditest$prueba, "[", 1)
preditest$Rep <- sapply(preditest$prueba, "[", 2)
preditest$prueba<-NULL
tasafallos<-function(x,y) {
confu<-confusionMatrix(x,y)
tasa<-confu[[3]][1]
return(tasa)
}
# Aplicamos función sobre cada Repetición
tabla<-table(preditest$Rep)
listarep<-c(names(tabla))
medias<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
tasa=1-tasafallos(paso1$pred,paso1$obs)
medias<-rbind(medias,tasa)
}
names(medias)<-"tasa"
# CalculamoS AUC  por cada Repetición de cv
# Definimnos función
auc<-function(x,y) {
curvaroc<-roc(response=x,predictor=y)
auc<-curvaroc$auc
return(auc)
}
# Aplicamos función sobre cada Repetición
mediasbis<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
auc=suppressMessages(auc(paso1$obs,paso1$Yes))
mediasbis<-rbind(mediasbis,auc)
}
names(mediasbis)<-"auc"
# Unimos la info de auc y de tasafallos
medias$auc<-mediasbis$auc
return(list(medias,preditest))
}
# ***************************************************************
# svmRadial: parámetros
# Sigma (sigma, numeric)
# Cost (C, numeric)
# PONER linout = FALSE
# ***************************************************************
cruzadaSVMbinRBF<-
function(data=data,vardep="vardep",
listconti="listconti",listclass="listclass",
grupos=4,sinicio=1234,repe=5,
C=1,sigma=1)
{
# Preparación del archivo
# b)pasar las categóricas a dummies
if (any(listclass==c(""))==FALSE)
{
databis<-data[,c(vardep,listconti,listclass)]
databis<- dummy.data.frame(databis, listclass, sep = ".")
}  else   {
databis<-data[,c(vardep,listconti)]
}
# c)estandarizar las variables continuas
# Calculo medias y dtipica de datos y estandarizo (solo las continuas)
means <-apply(databis[,listconti],2,mean)
sds<-sapply(databis[,listconti],sd)
# Estandarizo solo las continuas y uno con las categoricas
datacon<-scale(databis[,listconti], center = means, scale = sds)
numerocont<-which(colnames(databis)%in%listconti)
databis<-cbind(datacon,databis[,-numerocont,drop=FALSE ])
databis[,vardep]<-as.factor(databis[,vardep])
formu<-formula(paste("factor(",vardep,")~.",sep=""))
# Preparo caret
set.seed(sinicio)
control<-trainControl(method = "repeatedcv",number=grupos,repeats=repe,
savePredictions = "all",classProbs=TRUE)
# Aplico caret y construyo modelo
SVMgrid <-expand.grid(C=C,sigma=sigma)
SVM<- train(formu,data=databis,
method="svmRadial",trControl=control,
tuneGrid=SVMgrid,replace=replace)
print(SVM$results)
preditest<-SVM$pred
preditest$prueba<-strsplit(preditest$Resample,"[.]")
preditest$Fold <- sapply(preditest$prueba, "[", 1)
preditest$Rep <- sapply(preditest$prueba, "[", 2)
preditest$prueba<-NULL
tasafallos<-function(x,y) {
confu<-confusionMatrix(x,y)
tasa<-confu[[3]][1]
return(tasa)
}
# Aplicamos función sobre cada Repetición
tabla<-table(preditest$Rep)
listarep<-c(names(tabla))
medias<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
tasa=1-tasafallos(paso1$pred,paso1$obs)
medias<-rbind(medias,tasa)
}
names(medias)<-"tasa"
# CalculamoS AUC  por cada Repetición de cv
# Definimnos función
auc<-function(x,y) {
curvaroc<-roc(response=x,predictor=y)
auc<-curvaroc$auc
return(auc)
}
# Aplicamos función sobre cada Repetición
mediasbis<-data.frame()
for (repi in listarep) {
paso1<-preditest[which(preditest$Rep==repi),]
auc=suppressMessages(auc(paso1$obs,paso1$Yes))
mediasbis<-rbind(mediasbis,auc)
}
names(mediasbis)<-"auc"
# Unimos la info de auc y de tasafallos
medias$auc<-mediasbis$auc
return(list(medias,preditest))
}
gradient_boosting <- cruzadagbmbin(data=surgical_dataset,
vardep=target,listconti=var_modelo2,
listclass=c(""),grupos=grupos,sinicio=sinicio,repe=repe,
n.minobsinnode=20,shrinkage=0.2,n.trees=100,
interaction.depth=2, bag.fraction=0.5)
grupos
gradient_boosting
medias_gradient_boosting    <- as.data.frame(gradient_boosting[1])
medias_gradient_boosting$modelo <-"Gradient_Boosting"
pred_gradient_boosting      <- as.data.frame(gradient_boosting[2])
pred_gradient_boosting$logi <- pred_gradient_boosting$Yes
pred_gradient_boosting
# XGboost
xgboost <- cruzadaxgbmbin(data=surgical_dataset,vardep=target,
listconti=var_modelo2,listclass=c(""),
grupos=grupos,sinicio=sinicio,repe=repe,
min_child_weight=20,eta=0.1,nrounds=100,max_depth=6,
gamma=0,colsample_bytree=1,subsample=0.5)
xgboost
medias_xgboost    <- as.data.frame(xgboost[1])
medias_xgboost$modelo <-"XGboost"
pred_xgboost      <- as.data.frame(xgboost[2])
pred_xgboost$logi <- pred_xgboost$Yes
pred_xgboost
save.image("~/UCM/Machine Learning/Practica ML/MachineLearning/rdata/Ensamblado.RData")
